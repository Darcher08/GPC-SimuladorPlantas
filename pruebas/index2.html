<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>FBX loader</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
      }
      #canvas-container {
        width: 100vw;
        height: 100vh;
      }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 15px;
        border-radius: 5px;
        max-width: 300px;
      }
      #controls {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 15px;
        border-radius: 5px;
      }
      button {
        margin: 5px 0;
        padding: 8px 15px;
        cursor: pointer;
        width: 100%;
      }
      .success {
        color: #4caf50;
      }
      .error {
        color: #f44336;
      }
      .status {
        color: #2196f3;
      }
    </style>
  </head>
  <body>
    <div id="canvas-container"></div>

    <div id="info">
      <h3>Three.js FBX Loader</h3>
      <p><strong>Controles:</strong></p>
      <ul style="margin: 5px 0; padding-left: 20px">
        <li>Click + arrastrar: rotar</li>
        <li>Scroll: zoom</li>
      </ul>
      <div id="model-info" class="status">
        <p>Cargando modelo...</p>
      </div>
    </div>

    <div id="controls">
      <button onclick="resetCamera()">Reset Cámara</button>
      <button onclick="toggleWireframe()">Wireframe</button>
      <button onclick="toggleGrid()">Grid</button>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { FBXLoader } from "three/addons/loaders/FBXLoader.js";

      // ========================================
      // CONFIGURA AQUÍ LA RUTA DE TU ARCHIVO FBX
      // ========================================
      const FBX_PATH = "./hoja.fbx";
      // ========================================

      let scene, camera, renderer;
      let loadedModel = null;
      let wireframeMode = false;
      let gridHelper, axesHelper;
      let mixer = null;
      let clock = new THREE.Clock();

      // Inicializar escena
      function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x263238);

        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          2000
        );
        camera.position.set(10, 10, 10);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        document
          .getElementById("canvas-container")
          .appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.camera.left = -50;
        directionalLight.shadow.camera.right = 50;
        directionalLight.shadow.camera.top = 50;
        directionalLight.shadow.camera.bottom = -50;
        scene.add(directionalLight);

        const fillLight = new THREE.DirectionalLight(0x88ccff, 0.3);
        fillLight.position.set(-5, -5, -5);
        scene.add(fillLight);

        gridHelper = new THREE.GridHelper(50, 50, 0x444444, 0x222222);
        scene.add(gridHelper);

        axesHelper = new THREE.AxesHelper(10);
        scene.add(axesHelper);

        const planeGeometry = new THREE.PlaneGeometry(100, 100);
        const planeMaterial = new THREE.ShadowMaterial({ opacity: 0.3 });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2;
        plane.receiveShadow = true;
        scene.add(plane);

        setupControls();
        window.addEventListener("resize", onWindowResize);
        animate();

        // Cargar el modelo FBX automáticamente
        loadFBX();
      }

      // Controles con mouse
      function setupControls() {
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraRotation = { x: Math.PI / 6, y: Math.PI / 4 };

        renderer.domElement.addEventListener("mousedown", (e) => {
          isDragging = true;
          previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        renderer.domElement.addEventListener("mousemove", (e) => {
          if (isDragging) {
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;

            cameraRotation.y += deltaX * 0.005;
            cameraRotation.x = Math.max(
              -Math.PI / 2 + 0.1,
              Math.min(Math.PI / 2 - 0.1, cameraRotation.x - deltaY * 0.005)
            );

            updateCameraPosition();
            previousMousePosition = { x: e.clientX, y: e.clientY };
          }
        });

        renderer.domElement.addEventListener("mouseup", () => {
          isDragging = false;
        });

        renderer.domElement.addEventListener("wheel", (e) => {
          e.preventDefault();
          const delta = e.deltaY * 0.01;
          const radius = camera.position.length();
          const newRadius = Math.max(2, Math.min(200, radius + delta));
          camera.position.multiplyScalar(newRadius / radius);
        });

        function updateCameraPosition() {
          const radius = camera.position.length();
          camera.position.x =
            radius * Math.sin(cameraRotation.y) * Math.cos(cameraRotation.x);
          camera.position.y = radius * Math.sin(cameraRotation.x);
          camera.position.z =
            radius * Math.cos(cameraRotation.y) * Math.cos(cameraRotation.x);
          camera.lookAt(0, 0, 0);
        }
      }

      // Cargar FBX automáticamente
      function loadFBX() {
        updateInfo(`<p class="status">Cargando: ${FBX_PATH}...</p>`, "status");

        const loader = new FBXLoader();

        loader.load(
          FBX_PATH,
          function (object) {
            loadedModel = object;
            scene.add(object);

            // Habilitar sombras
            object.traverse((child) => {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
              }
            });

            // Centrar y escalar modelo
            const box = new THREE.Box3().setFromObject(object);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());

            object.position.sub(center);

            const maxDim = Math.max(size.x, size.y, size.z);
            const scale = 10 / maxDim;
            object.scale.setScalar(scale);

            // Info del modelo
            let info = `<p class="success">✓ Modelo cargado: ${FBX_PATH.split(
              "/"
            ).pop()}</p>`;
            info += `<p>Dimensiones: ${size.x.toFixed(2)} x ${size.y.toFixed(
              2
            )} x ${size.z.toFixed(2)}</p>`;

            let meshCount = 0;
            let vertexCount = 0;
            let materialInfo = [];

            object.traverse((child) => {
              if (child.isMesh) {
                meshCount++;
                if (child.geometry) {
                  vertexCount += child.geometry.attributes.position.count;
                }

                if (child.material) {
                  const mat = child.material;
                  let matText = `<strong>${child.name || "Mesh"}:</strong><br>`;

                  if (mat.map) matText += `&nbsp;&nbsp;- Color Map: ✓<br>`;
                  if (mat.normalMap)
                    matText += `&nbsp;&nbsp;- Normal Map: ✓<br>`;
                  if (mat.roughnessMap)
                    matText += `&nbsp;&nbsp;- Roughness Map: ✓<br>`;
                  if (mat.metalnessMap)
                    matText += `&nbsp;&nbsp;- Metalness Map: ✓<br>`;

                  materialInfo.push(matText);
                }
              }
            });

            info += `<p>Meshes: ${meshCount}<br>Vértices: ${vertexCount.toLocaleString()}</p>`;

            if (materialInfo.length > 0) {
              info += "<p><strong>Materiales y Texturas:</strong></p>";
              materialInfo.forEach(
                (mat) =>
                  (info += `<p style="font-size:12px; margin:5px 0;">${mat}</p>`)
              );
            }

            // Animaciones
            if (object.animations && object.animations.length > 0) {
              info += `<p>Animaciones: ${object.animations.length}</p>`;
              mixer = new THREE.AnimationMixer(object);
              const action = mixer.clipAction(object.animations[0]);
              action.play();
            }

            updateInfo(info, "success");
          },
          function (xhr) {
            const percent = ((xhr.loaded / xhr.total) * 100).toFixed(0);
            updateInfo(
              `<p class="status">Cargando... ${percent}%</p>`,
              "status"
            );
          },
          function (error) {
            updateInfo(
              `<p class="error">Error al cargar FBX:<br>${error.message}<br><br>Verifica que la ruta sea correcta y que estés usando un servidor local.</p>`,
              "error"
            );
            console.error("Error detallado:", error);
          }
        );
      }

      function updateInfo(html, className) {
        const infoDiv = document.getElementById("model-info");
        infoDiv.innerHTML = html;
        infoDiv.className = "status " + className;
      }

      window.resetCamera = function () {
        camera.position.set(10, 10, 10);
        camera.lookAt(0, 0, 0);
      };

      window.toggleWireframe = function () {
        wireframeMode = !wireframeMode;
        if (loadedModel) {
          loadedModel.traverse((child) => {
            if (child.isMesh) {
              child.material.wireframe = wireframeMode;
            }
          });
        }
      };

      window.toggleGrid = function () {
        gridHelper.visible = !gridHelper.visible;
        axesHelper.visible = !axesHelper.visible;
      };

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);

        const delta = clock.getDelta();
        if (mixer) mixer.update(delta);

        renderer.render(scene, camera);
      }

      init();
    </script>
  </body>
</html>
