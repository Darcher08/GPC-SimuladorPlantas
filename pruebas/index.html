<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three.js FBX Loader</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
      }
      #canvas-container {
        width: 100vw;
        height: 100vh;
      }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 15px;
        border-radius: 5px;
        font-size: 14px;
        max-width: 350px;
        max-height: 80vh;
        overflow-y: auto;
      }
      #controls {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px;
        border-radius: 5px;
      }
      button {
        background: #4caf50;
        color: white;
        border: none;
        padding: 8px 15px;
        margin: 5px;
        cursor: pointer;
        border-radius: 3px;
      }
      button:hover {
        background: #45a049;
      }
      input[type="file"] {
        margin: 5px 0;
        color: white;
      }
      .status {
        margin-top: 10px;
        padding: 8px;
        border-radius: 3px;
        background: rgba(255, 255, 255, 0.1);
      }
      .error {
        color: #ff6b6b;
      }
      .success {
        color: #51cf66;
      }
    </style>
  </head>
  <body>
    <div id="canvas-container"></div>

    <div id="info">
      <h3>Three.js FBX Loader</h3>
      <p><strong>Controles:</strong></p>
      <ul style="margin: 5px 0; padding-left: 20px">
        <li>Click + arrastrar: rotar</li>
        <li>Scroll: zoom</li>
      </ul>
      <div id="model-info" class="status">
        <p>Carga un archivo FBX para comenzar</p>
      </div>
    </div>

    <div id="controls">
      <input type="file" id="fbx-input" accept=".fbx" />
      <br />
      <button onclick="resetCamera()">Reset Cámara</button>
      <button onclick="toggleWireframe()">Wireframe</button>
      <button onclick="toggleGrid()">Grid</button>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { FBXLoader } from "three/addons/loaders/FBXLoader.js";

      let scene, camera, renderer;
      let loadedModel = null;
      let wireframeMode = false;
      let gridHelper, axesHelper;
      let mixer = null; // Para animaciones
      let clock = new THREE.Clock();

      // Inicializar escena
      function init() {
        // Escena
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x263238);

        // Cámara
        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          2000
        );
        camera.position.set(10, 10, 10);
        camera.lookAt(0, 0, 0);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document
          .getElementById("canvas-container")
          .appendChild(renderer.domElement);

        // Luces
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        //scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 0, 0);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.camera.left = -50;
        directionalLight.shadow.camera.right = 50;
        directionalLight.shadow.camera.top = 50;
        directionalLight.shadow.camera.bottom = -50;
        scene.add(directionalLight);

        // Luz de relleno
        const fillLight = new THREE.DirectionalLight(0x88ccff, 0.3);
        fillLight.position.set(-5, -5, -5);
        scene.add(fillLight);

        // Grid y ejes
        gridHelper = new THREE.GridHelper(50, 50, 0x444444, 0x222222);
        scene.add(gridHelper);

        axesHelper = new THREE.AxesHelper(10);
        scene.add(axesHelper);

        // Plano para sombras
        const planeGeometry = new THREE.PlaneGeometry(100, 100);
        const planeMaterial = new THREE.ShadowMaterial({ opacity: 0.3 });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2;
        plane.receiveShadow = true;
        scene.add(plane);

        // Controles
        setupControls();

        // Resize
        window.addEventListener("resize", onWindowResize);

        animate();
      }

      // Controles con mouse
      function setupControls() {
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraRotation = { x: Math.PI / 6, y: Math.PI / 4 };

        renderer.domElement.addEventListener("mousedown", (e) => {
          isDragging = true;
          previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        renderer.domElement.addEventListener("mousemove", (e) => {
          if (isDragging) {
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;

            cameraRotation.y += deltaX * 0.005;
            cameraRotation.x = Math.max(
              -Math.PI / 2 + 0.1,
              Math.min(Math.PI / 2 - 0.1, cameraRotation.x - deltaY * 0.005)
            );

            updateCameraPosition();
            previousMousePosition = { x: e.clientX, y: e.clientY };
          }
        });

        renderer.domElement.addEventListener("mouseup", () => {
          isDragging = false;
        });

        renderer.domElement.addEventListener("wheel", (e) => {
          e.preventDefault();
          const delta = e.deltaY * 0.01;
          const radius = camera.position.length();
          const newRadius = Math.max(2, Math.min(200, radius + delta));
          camera.position.multiplyScalar(newRadius / radius);
        });

        function updateCameraPosition() {
          const radius = camera.position.length();
          camera.position.x =
            radius * Math.sin(cameraRotation.y) * Math.cos(cameraRotation.x);
          camera.position.y = radius * Math.sin(cameraRotation.x);
          camera.position.z =
            radius * Math.cos(cameraRotation.y) * Math.cos(cameraRotation.x);
          camera.lookAt(0, 0, 0);
        }
      }

      // Cargar FBX
      document
        .getElementById("fbx-input")
        .addEventListener("change", (event) => {
          const file = event.target.files[0];
          if (!file) return;

          updateInfo("Cargando archivo FBX...", "status");

          const reader = new FileReader();
          reader.onload = function (e) {
            loadFBXFromArrayBuffer(e.target.result, file.name);
          };
          reader.readAsArrayBuffer(file);
        });

      function loadFBXFromArrayBuffer(arrayBuffer, filename) {
        // Remover modelo anterior
        if (loadedModel) {
          scene.remove(loadedModel);
          loadedModel = null;
        }

        const loader = new FBXLoader();

        try {
          const object = loader.parse(arrayBuffer, "");

          loadedModel = object;
          scene.add(object);

          // Habilitar sombras
          object.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });

          // Centrar y escalar modelo
          const box = new THREE.Box3().setFromObject(object);
          const center = new THREE.Vector3(0, 0, 0); //box.getCenter(new THREE.Vector3());
          const size = box.getSize(new THREE.Vector3());

          object.position.sub(center);

          const maxDim = Math.max(size.x, size.y, size.z);
          const scale = 10 / maxDim;
          object.scale.setScalar(scale);

          // Info del modelo
          let info = `<p class="success">✓ Modelo cargado: ${filename}</p>`;
          info += `<p>Dimensiones: ${size.x.toFixed(2)} x ${size.y.toFixed(
            2
          )} x ${size.z.toFixed(2)}</p>`;

          let meshCount = 0;
          let vertexCount = 0;
          let materialInfo = [];

          object.traverse((child) => {
            if (child.isMesh) {
              meshCount++;
              if (child.geometry) {
                vertexCount += child.geometry.attributes.position.count;
              }

              // Info de materiales y texturas
              if (child.material) {
                const mat = child.material;
                let matText = `<strong>${child.name || "Mesh"}:</strong><br>`;

                if (mat.map) {
                  matText += `&nbsp;&nbsp;- Color Map: ${
                    mat.map.image?.currentSrc ? "✓" : "referencia encontrada"
                  }<br>`;
                }
                if (mat.normalMap) {
                  matText += `&nbsp;&nbsp;- Normal Map: ${
                    mat.normalMap.image?.currentSrc
                      ? "✓"
                      : "referencia encontrada"
                  }<br>`;
                }
                if (mat.roughnessMap) {
                  matText += `&nbsp;&nbsp;- Roughness Map: ✓<br>`;
                }
                if (mat.metalnessMap) {
                  matText += `&nbsp;&nbsp;- Metalness Map: ✓<br>`;
                }

                materialInfo.push(matText);
              }
            }
          });

          info += `<p>Meshes: ${meshCount}<br>Vértices: ${vertexCount.toLocaleString()}</p>`;

          if (materialInfo.length > 0) {
            info += "<p><strong>Materiales y Texturas:</strong></p>";
            materialInfo.forEach(
              (mat) =>
                (info += `<p style="font-size:12px; margin:5px 0;">${mat}</p>`)
            );
          }

          // Animaciones
          if (object.animations && object.animations.length > 0) {
            info += `<p>Animaciones: ${object.animations.length}</p>`;
            mixer = new THREE.AnimationMixer(object);
            const action = mixer.clipAction(object.animations[0]);
            action.play();
          }

          updateInfo(info, "success");
        } catch (error) {
          updateInfo(
            `<p class="error">Error al cargar FBX:<br>${error.message}</p>`,
            "error"
          );
          console.error("Error detallado:", error);
        }
      }

      function updateInfo(html, className) {
        const infoDiv = document.getElementById("model-info");
        infoDiv.innerHTML = html;
        infoDiv.className = "status " + className;
      }

      window.resetCamera = function () {
        camera.position.set(10, 10, 10);
        camera.lookAt(0, 0, 0);
      };

      window.toggleWireframe = function () {
        wireframeMode = !wireframeMode;
        if (loadedModel) {
          loadedModel.traverse((child) => {
            if (child.isMesh) {
              child.material.wireframe = wireframeMode;
            }
          });
        }
      };

      window.toggleGrid = function () {
        gridHelper.visible = !gridHelper.visible;
        axesHelper.visible = !axesHelper.visible;
      };

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);

        const delta = clock.getDelta();
        if (mixer) mixer.update(delta);

        renderer.render(scene, camera);
      }

      // Iniciar
      init();
    </script>
  </body>
</html>
